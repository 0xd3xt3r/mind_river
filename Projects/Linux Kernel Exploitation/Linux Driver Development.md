---
up: "[[Knowledge Base MoC]]"
tags:
  - "#type/os/linux"
status:
  - todo
created-date: 2024-12-15
related: 
summary: Linux Kernel driver dev
---

## Notes

- The kernel framework it registers itself to depends on the type of device you are working with; for example, The kernel framework it registers itself to depends on the type of device you are working with. Each type of device has its down registration API like i2c_register_driver, register_netdev and pci_register_driver.

## Char Driver

- gain access to the underlying device driver within the kernel, some I/O mechanism is required. process open a special type of file – a **device file**, or **device node**
- Char devices are accessed through names in the filesystem. Those names are called special files or device files or simply nodes of the filesystem tree; they are conventionally located in the /dev directory.
- Special files for char drivers are identified by a "c" in the first column of the output of ls –l. Block devices appear in /dev as well, but they are identified by a "b."
- These numbers are the major and minor device number for the particular device
- Modern Linux kernels allow multiple drivers to share major numbers, but most devices that you will see are still organized on the  *one-major-one-driver* principle.
- the major number identifies the driver associated with the device. For example, /dev/null and /dev/zero are both managed by driver 1, whereas virtual consoles and serial terminals are managed by driver 4;
- The minor number is used by the kernel to determine exactly which device is being referred to.
- Within the kernel, the dev_t type (defined in <linux/types.h>) is used to hold device numbers—both the major and minor parts. 


## Block Driver

- block devices have the (kernel-level) capability to be mounted and thus become part of the user-accessible filesystem.block devices have the (kernel-level) capability to be mounted and thus become part of the user-accessible filesystem.

## Platform Driver

- If a new device surfaces (perhaps you plugged in a pen drive), the USB bus driver will recognize the fact and bind it to its (USB mass storage) device driver! Once successfully bound (many terms are used to describe this: bound, enumerated, discovered), the kernel driver framework invokes the registered probe() method (function) of the driver. This probe method now sets up the device, allocating resources, IRQs, memory setup, registering it as required, and so on.
- Conversely, when the device is detached from the bus or the kernel module is unloaded (or the system is shutting down), the detach causes the driver's remove() (or disconnect()) method to be invoked.