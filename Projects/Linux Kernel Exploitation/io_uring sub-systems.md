---
up: "[[Knowledge Base MoC]]"
tags:
  - "#type/os/linux"
status:
  - done
created-date: 2024-12-15
related: 
summary: exploiting bugs in "inux io_uring sub-system
---

tags : #linux, #io_uring


[[io_uring]] is a new asyn I/O sub-system for Linux. its mean to replace **aio** sub-system.

###  CVE Vulnerability
^86e0ef

1. CVE-2021-3491
	1. [Mitre](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3491)
	2. Integer overflow leading to heap overflow and heap overflow leading to arbitrary code execution in the kernel
	3. Linux kernel [[io_uring]] PROVIDE_BUFFERS MAX_RW_COUNT bypass
	4. It was introduced in [ddf0322db79c]()
	5. It was fixed via commit [d1f82808877b](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d1f82808877bb10d3deee7cf3374a4eb3fb582db)
	6. Backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37
	7. https://blog.haboob.sa/blog/cve-2021-3491-triggering-a-linux-kernel-iouring-overflow
3. CVE-2021-41073
	1. Bug class [[UAF]]
	2. Gain privileges by using IORING_OP_PROVIDE_BUFFERS to trigger a free of a kernel buffer
	3. The bug pattern in this exploit is that `kvfree` is called in the form `kvfree(buf_to_free + offset)` and offset can be controlled by the user. So instead of target buffer we will be freeing adjust buffer of **offset** we desire
	4. Exploit Primitives
		1. For leak primitive 
			1. First call [setxattr](https://man7.org/linux/man-pages/man2/setxattr.2.html) syscall which prototype `setxattr(const char *path, const char *name, const void *value, size_t size, int flags)`. This call allows us to allocate kernel buffer of any size less than `XATTR_SIZE_MAX` via size param. The buffer content can also be controlled by us so we import any data kernel buffer and that data is supplied by third param value of setxattr call. When doing `copy_from_user` in syscall it will block the kernel thread because the source data is from [[userfaultfd]] blocking page. We will choose the buffer of size 32 and content doesn't matter it will be overwritten with the data we want to leak
			3. The kmalloc-32 buffer allocated by setxattr syscall will be next to the io_uring buffer and using the UAF bug we free this buffer.
			4. Now we allocate object we want to leak and after the allocation we unlock the **userfaultfd** page.
			5. To extract the leak data we call [getxattr](https://man7.org/linux/man-pages/man2/getxattr.2.html) system call which has prototype `ssize_t getxattr(const char *path, const char *name, void *value, size_t size);` The third parameter will get the kernel leak data.
		3. For write primitive
			1. The write primitive is pretty much the same as read primitive but here instead of providing blocker page in third parameter of setxattr syscall we provide it in third parameter of getxattr syscall.
	5. Issues I figured while working
		1. Memory allocator issues
			1. you to disable CONFIG_MEMCG config in kernel, by default is disable for security reason, I think it was used as some sort of leak primitive.
			2. Playing around with some victim objects, I noticed that I could never reliably allocate them around `struct xt_table_info` on kernel 5.4. I realized that it had something to do with the `GFP_KERNEL_ACCOUNT` flag, as other objects allocated with `GFP_KERNEL_ACCOUNT` did not have this issue. Jann Horn confirmed that before 5.9, separate slabs were used to implement _accounting_. Therefore, every heap primitive we use in the exploit chain should also use `GFP_KERNEL_ACCOUNT`. The syscall `msgsnd()` is a well known primitive for heap spraying (which uses `GFP_KERNEL_ACCOUNT`) and has been utilized for multiple public exploits already.
			3. Finding a victim object - (https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html#finding-a-victim-object) The best victim to attack is one that has a function pointer in its structure. Remember that the victim must also be allocated with `GFP_KERNEL_ACCOUNT`
	6. tracing grep `grep "iou-wrk-\|test-" /sys/kernel/debug/tracing/trace`
	7. Exploitation write-up for this bug is on this [link](https://web.archive.org/web/20221129095546/https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel)
	8. It was fixed via commit [6c8d2df7ec0e](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=16c8d2df7ec0eed31b7d3b61cb13206a7fb930cc)
	9. https://www.starlabs.sg/blog/2022/06-io_uring-new-code-new-bugs-and-a-new-exploit-technique/
5. CVE-2021â€“20226
	1. a reference counting bug which leads to local privilege escalation in io_uring.
	2. There are two writeup, [link1](https://flattsecurity.medium.com/cve-2021-20226-a-reference-counting-bug-which-leads-to-local-privilege-escalation-in-io-uring-e946bd69177a) and [link2](https://www.zerodayinitiative.com/blog/2021/4/22/cve-2021-20226-a-reference-counting-bug-in-the-linux-kernel-iouring-subsystem)
6. [CVE 2019-19241](https://nvd.nist.gov/vuln/detail/CVE-2019-19241)
	1. Write up [link](https://www.exploit-db.com/exploits/47779)
3. This [blog](https://ruia-ruia.github.io/NFC-UAF/) used uring io as an exploit primitive