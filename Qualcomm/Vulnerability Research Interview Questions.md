# Interview Questions

Tags : #interview-questions

## Systems Understanding
1. User kernel interaction
2. Memory mapped IO vs Port IO
3. Peripheral communication

## Secure C


## Exploitation

1.  What is stack overflow? How does it work?
3.  Exploit mitigation technique (ASLR, ROP, DEP)
4.  How does ROP work?
	1.  How to do ROP when buffer size is small? (Stack pivot)
5.  What is Null pointer de-referencing?
6.  Heap Exploit Mitigation from heap allocator perspective
	1. ASLR
	2. DEP
	3. Stack Canary
	4. CFI - control flow integrity
	5. Pointer Authentication
7.  what will you look bugs for in Linux based firmware?
8.  What is Shellcode?
9.  In what cases can all the exploit mitigation can fail?
10. How can you use UAF to achieve process control?
11. What are different vulnerability classes?
	1. Memory corruption
		1. Stack overflow
		2. Heap overflow
	2. Integer overflow
	3. Format strings
	4. Use-After-Free
	5. Double free
	6. Off by one
	7. Race condition
	8. Stack reuse attack.
	9. uninitialized variables
	10. Null pointer dereference
	11. Array index - pointer arithmetic
	12. Out of bounds Read/Write

## Reverse Engineering

1.  How would you reverse bare-metal firmware?


## Fuzzing

1. What is the role of code-coverage in fuzzing? Does it help you to improve the outcome?
2. How would you do static code analysis.
3. How to detect bugs with fuzzing which doesn't generate any crash? (Like buffer overflow)
4.  What is Address Sanitizer(ASAN), Heap SANITIZER.
5.  What make AFL a good fuzzer? What are the things about it that helps it find so many bugs?
	1.  Code coverage
	2.  Mutation Engine
	3.  Feedback based fuzzing
6.  What snapshot fuzzing? What are its advantage?

## Generic
1. Can you describe any interesting challenge you have worked in your career.
2. What other things have you worked on other then your work?


## Code Review

### Off by One byte


```C

int is_authenticated(char *sm) {

	char buffer[8];
	int i;
	int auth = 0;

	for(i = 0; i <= 8; i++)
		buffer[i] = sm[i];

	printf("We ran %d times (or %d).\n", auth, i);
	
	if (auth)
		printf("Authenticated!\n");

	return auth;
}

void main(int argc, char *argv[]) {

	if (argc < 1) {
		printf("Invalid arguments\n");
		exit(-1);
	}

	is_authenticated(argv[1]);

}

```

**Solution** - 
- `for(i = 0; **i <= 8**;  i++)` should be `for(i = 0; **i < 8 **; i++)`

###  Integer overflow

#### Challenge 1

```C
int main() {

	int i;

	short s=32768;
	short t=78000;

	int array[100000];

	for(i = 0; i < 100000; i++) {
		array[i] = i;
	}

	printf("\nValue @ position s = %d", array[s]);
	printf("\nValue @ position t = %d", array[t]);
	printf("\nValue @ position 78000 = %d", array[78000]);

}
```

**Solutions**
1. malloc integer overflow (len+1)
2. strncpy overflow even if malloc returns data
3. if malloc return null is null-deference

#### Challenge 2

```C
#define MAX_RW_COUNT 64

typedef unsigned int __u32;

#define MIN(a, b) (((a) < (b)) ? (a) : (b))


struct io_buffer {
	int list[10];
	unsigned long addr;
	unsigned int len;	
	unsigned int bid;
};

struct io_provide_buf {
	struct file *file;
	unsigned long addr;
	unsigned int len;
	unsigned int bgid;
	unsigned int nbufs;
	unsigned int bid;
};

struct file {
	int size;
};

static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head) {
	printf("io_add_buffers method called\n");
	struct io_buffer *buf;
	unsigned long int addr = 4328742;
	unsigned int bid = 10;
	buf->addr = addr;
	buf->len = pbuf->len;
	printf("Buffer length: %d\n", buf->len);
	buf->bid = bid;
	addr += pbuf->len;
	return 0;
}

int main(int argc, char* argv[]) {

	int list[10] = {23, 54, 11, 76, 30, 45, 98, 11, 4, 65};
	struct io_buffer iobuf0 = {list, 291870, 10, 3};
	struct file file = {1};
	struct io_provide_buf ioprovidebuf0 = {&file, 47032, 70, 12, 42, 33};
	struct io_provide_buf *pbuf;
	pbuf = &ioprovidebuf0;
	printf("Initialized io provide buffer\n");
	struct io_buffer *buf;
	buf = &iobuf0;
	printf("Initialized io buffer\n");
	int rv = io_add_buffers(pbuf, &buf);
	return 0;
}
```

#### Challenge 3

```C
void call_str(int len, char *name) {
 	void *ptr = malloc(len + 1);
 	if (!ptr) {
        printf("Invalid allocation\n");
        return -1;
    }
 	strncpy(ptr, name, len);
}

int main(int argc, char argv[]) {
	if (argc < 2) {
		printf("Invalid arguments\n");
		exit(-1);
	}
	char *name;
 	int alloc_size = atoi(argv[1]);
 	call_str(alloc_size, argv[2]);
}
```

### Logical Bug

```C

int get_handle(int context_id, int handle_id)
{
    int valid_handle[32];
    
    if (!context_id || (handle_id <= 0 && handle_id >= 32)) {
        printf("Invalid parameter\n");
		return -1;
    }
    int idx = handle_id - 1;
    
    return valid_handle[idx];
}

void main(int argc, char *argv[]) {

	if (argc < 2) {
		printf("Invalid arguments\n");
		exit(-1);
	}
	int handle_id = atoi(argv[1]);
	int context_id = atoi(argv[2]);
	get_handle(context_id, handle_id);

}

```

### Stack re-use attack


### Heap overflow