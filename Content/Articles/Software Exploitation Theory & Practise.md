---
up: "[[Writing MoC]]"
tags:
  - type/writing/article
status: todo
created-date: 2024-12-10
---

## Introduction

To truly understand the concept of Vulnerability Research & Software Exploitation, it’s crucial to understand the process through which attackers identify bugs and leverage to achieve code execution, thereby gaining control over a victim’s device or PC. Finding vulnerability and exploiting it are distinct, each demanding its own level of expertise. This discussion goes beyond the basics of Buffer Overflow, delving into various bug classes such as Use-After-Free, heap overflow, Race-condition bugs, Logic Bugs, and more. However, attempting to directly attack real-world software can be daunting due to the complexity of the code base and the intricacies of exploitation, which can lead to frustration.

In the process of bug discovery, we employ methods such as Static Analysis (utilizing tools like weggli, semgrep, etc.), fuzzing (with tools like AFL, Syzkaller, Peach Fuzzer, etc.), and code auditing (using Emacs, Eyes, and Brains). However, for the purpose of this discussion, let’s focus on the aspect of exploitation, and we can delve into the topic of bug discovery in a future conversation.

Binary exploitation is a challenging subject because to its steep learning curve. You need to have a deep understanding of various concepts such as Operating Systems, Assembly language, Memory models, and Bug classes. When I mention a steep curve, it implies that at one end of the curve, we have the classic buffer overflow (a topic extensively covered in numerous introductory tutorials), while midway through the curve, we encounter real-world targets like Heap exploitation, File Format and media file parsing bugs. As we ascend higher on the curve, we encounter more complex targets like Web Browsers, Operating System Kernels, and Hypervisors. Without a systematic approach to this subject, there’s a high likelihood of abandoning the journey midway.

## Static & Dynamic Approach

## Fuzzing
in this method you feed random inputs to your target with user-controlled data, observer for any crashes. You collect all the inputs that caused the crash and analyze it for security issues. Important thing note here is that this is a dynamic approach, where you are executing the code unlike Static Analysis.

So if you are dealing with Linux or Windows based target then there numerous fuzzing tools like AFL++, WinAFL, Hongfuzz and what-not. But if you dealing with Embedded Systems and you need to figure-out a way to trigger the target code on device and observer crashes and restart the target. You need to keep doing that automatically to execute as many test case as possible.

## Code Auditing

While above two technique are Static and Dynamic approach they both need a very crucial input and that is understand of the Target Application. Different targets are different software pattern and different set of challenges. Here is a rough category of targets:

1. Network Service like Web Server, Game Server, RDP Server/Client, etc.
2. Media Codec/File Format parser, for eg JPEG, MP4, PDF, Docx
3. Operating System Kernels like Linux, Windows, XNU, RTOS, etc.
4. Web Browser like Rendering Engine, DOM Parser, Javascript Engine, etc.

This understanding is developed from Code Auditing. 

Understand the Use-cases, Entry Points, Data Flow, UML, Trust boundaries of the software this will help you create the Threat Modelling. Identify the Asserts of the system and list down the threats.

## Static Analysis

Static Analysis is basically trying to find vulnerabilities by pattern matching. Vulnerability pattern are expressed in a query language provide by the Static Analysis tool. These tools tend to create internal model of the target code base and based on the query it match that model just like SQL query matches the data stored in Database.

When programmers write code they tend to recognize some common problems of the application and solve them with common solution(like creating a linked-list library), this idea tend to evolve in to something call as Design Pattern. Just like a good design pattern can solve a problem, a bad pattern can lead you into one. Yes! a Software Vulnerability.

## Exploit Mitigations

Another challenge with modern day exploitation is that there are several exploit mitigation technique like ASLR, CFI, Stack canaries, DEP, etc. which makes exploitation harder and unreliable. But then there are technique to bypass those mitigation like ROP, leaking addresses, etc. which add to the complexities of exploitation. To bypass these techniques you need find multiple bugs and you need to chain these bugs in order to successfully exploit the targets.

Essential aspect of Software Exploitation is discovering new vulnerabilities. When your get into the problem of finding new bugs there are several Strategies like Static Analysis, Fuzzing and Code Auditing. I tend to use these three strategies in my day-to-day work.


## Conclusion

Although it may seem like three different strategies/tooling but they are not! they actually compliment each other. But before talking about how we can combine them, lets first try to understand them individually.

Based on this understanding you can write the rules for common mistakes your team is making. You can also feed this understanding to the fuzzing harness to reach deeper part of the code.
