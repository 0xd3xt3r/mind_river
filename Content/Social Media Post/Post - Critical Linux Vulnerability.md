---
up: "[[Writing MoC]]"
tags: "#type/writing/social-media"
status: todo
created-date : 2025-04-05
---

ðŸš¨ **Wild Linux Kernel Bug Fixed After 5 Years!**
An interesting Integer overflow bug was fixed in Linux kernel 2 days ago.

A subtle Pointer Arithmetic bug was lurking in the Linux kernel since March 15, 2020, and it just got fixed on April 3, 2025. It lived in the most critical piece of software for 5 years!

What went wrong?

This line was the culprit: "struct geneve_opt *opt = (struct geneve_opt *)opts->u.data + opts->len;"

Lets understand the semantics of this line

What you see is pointer arithmetic issue, "opts->u.data" is an array of type "uint8_t" which is type-casted to "struct geneve_opt *" for addition and "opts->len" is added to obtain "opt". This arithmetic increment is done in the following manner "sizeof(struct geneve_opt) * opts->len". This arithmetic can push the pointer out-of-bounds.

If you still don't understand the issue, no problem you can take a look at the patch and understand what was the desired behavior of the code.

Fix Code : "struct geneve_opt *opt = (struct geneve_opt *)(opts->u.data + opts->len);"

From the fix you easily make out that author originally intended to increment the "opts->u.data" pointer as a "uint8_t" pointer instead of "struct geneve_opt" pointer.

The fix was remarkably simple! Just "move the cast after the addition" - now the math happens in `uint8_t` space as originally intended.

Fix commit - https://github.com/torvalds/linux/commit/1b755d8eb1ace3870789d48fbd94f386ad6e30be

The bug was introduced in this commit - https://github.com/torvalds/linux/commit/925d844696d9287f841d6b3e0ed62a35fb175970. The commit message also has the KASAN crash log.

Code path to the bug: sendmsg -> netlink_sendmsg -> netlink_unicast -> nfnetlink_rcv -> nfnetlink_rcv_batch -> nf_tables_newobj -> nft_obj_init -> nft_tunnel_obj_init -> memcpy


#Linux #KernelSecurity #PointerArithmetic #MemorySafety