---
up: "[[Research Paper MoC]]"
tags:
  - "#reading/research-paper"
  - type/os/android
status: todo
created-date: 2025-10-19
title: NASS - Fuzzing All Native Android System Services with Interface Awareness and Coverage
summary:
---

- [Paper Link](https://www.usenix.org/system/files/usenixsecurity25-mao.pdf)
- [Project Source Link](https://github.com/HexHive/NASS)

## Notes
1. Camera System Service Interface
	1. [AIDL](https://android.googlesource.com/platform/frameworks/av/+/master/camera/aidl/android/hardware/ICameraService.aidl)
	2. [Java Interface](https://developer.android.com/reference/android/hardware/camera2/package-summary)
	3. [CPP Interface](https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.CaptureCallback)
	4. Camera Server is the native service exposing camera driver to the android framework. It is a close-source and proprietary as it has vendor specific implementation for hardware the vendor has.
2. Three RPC Design Principle which help to design an algorithm called Deserialization-Guided Interface Extraction (DGIE).
	1. Abstraction of IPC Binding Code - IPC serialisation and de-serialisation code which is implemented by both client and the server.
	2. Entry-Point function - IPC Transport layer forwards the data to the IPC Processing Layer. Entry point is the processing layer.
	3. Standard Deserialisation Routines - this code is auto generated by the AIDL/gRPC/Thrift, the code is pretty much standard, to ensure consistency and backward compatibility. This can be true for other frameworks as well.
3. Attack Vector
	1. The App layer is sand-boxed by (selinux and seccomp filter) and only has access to very few system calls and Binder IPC calls.
	2. Binder Driver is the only part of the kernel application, since Binder enables the IPC between application and system service. This IPC by design has made Binder a prime target. The driver is complex as well.
	3. The System service are subjected to sandbox as well, but they have access to other service like Framework service has access to HAL service. Then attacking the HAL service can be access to the vendor specific kernel driver corresponding to the HAL service.
4. Challenges
	1. Automatic Interface extraction - The deserialization code while parsing can generate error and return early in the code execution. In order to effectively fuzz the interface you need to have proper interface definition. For open source you have IDL source files but in case of proprietary RPC server you need to have interface definition.
	2. Isolated code coverage - The problem of code coverage is effectively solved for binary target. The challenge lies in the RPC server is invoked by many process, collecting coverage only for the fuzzer process is important for find true coverage.
	3. Earlier work involved capturing Binder IPC traffic during phone usage(BinderCracker) but this will only recover interface for code which is triggered and not the whole interface, and it tires to recover the definition the the captured traffic.
5. NASS Design
	1. To solve both the challenges, it uses dynamic analysis. This is done by hooking the entry-point.
	2. First it identifies all the exposed RPC function. There are two thing to identify. First, the function which it is invoking and 2nd is the parameter of the function. Both of this thing together forms a function signature.
	3. The Parameter of the interface are de-serialized in sequence. Deserialization routines are found in Parcel.h and binder_parcel.h.

## Core Idea


## Connected Concepts
