# Software Fuzzing

## Thoughts & Reflection

- Stack Based coverage
	- Look into stack based [[coverage]]. I picked up this idea from the paper [Evaluating Fuzz Testing](https://arxiv.org/pdf/1808.09700). In that paper author talks about using stack base coverage to corpus minimization.
	- Travis Ormandy also talks about this in [Firefox NSS Bug](https://googleprojectzero.blogspot.com/2021/12/this-shouldnt-have-happened.html) in Google Project Zero blog.

## Research Papers

- [Evaluating Fuzz Testing](https://arxiv.org/pdf/1808.09700.pdf)
- [How to Spot Good Fuzzing Research](https://blog.trailofbits.com/2018/10/05/how-to-spot-good-fuzzing-research/)
- [Cupid : Automatic Fuzzer Selection for Collaborative Fuzzing](https://research.vu.nl/ws/portalfiles/portal/130179054/Cupid_Automatic_Fuzzer_Selection_for_Collaborative_Fuzzing.pdf)
- [DetTrace - Reproducible Containers](https://dl.acm.org/doi/pdf/10.1145/3373376.3378519)
- [Fuzzing paper feeds](https://wcventure.github.io/FuzzingPaper/)

## In-Memory fuzzing

- In this technique the fuzzer hooks the entry and exit point of the function we want to fuzz, then when the entry hook is hit the fuzzer and captures the execution from then on. and it repeatedly call this function with different parameters.
- the challenge of this method is that we need some method to tracking restoring the side effect caused by the function which we are fuzzing.

1. [In memory fuzzing](https://diglib.tugraz.at/download.php?id=576a78fa4aae7&location=browse)

### Exp : Creating Snapshot of process

- How to create snapshot of process
- How to track and dump dirty pages of memory
- [Share Dirty Pages information](https://unix.stackexchange.com/questions/33381/getting-information-about-a-process-memory-usage-from-proc-pid-smaps)

## Fuzzing Tools

## Snapshot Fuzzing

### Ref

1. https://doar-e.github.io/blog/2021/07/15/building-a-new-snapshot-fuzzer-fuzzing-ida/
2. https://blog.ret2.io/2021/07/21/wtf-snapshot-fuzzing/


### AFL

###  co-projects
1. https://github.com/vanhauser-thc/afl-cov
2. [A grammar-based custom mutator for AFL++ to handle highly-structured inputs.](https://github.com/AFLplusplus/Grammar-Mutator)
3. [Writing Custom Mutator in AFL++](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/custom_mutators.md)
4. [AFL++ project](https://github.com/AFLplusplus/AFLplusplus)
5. [AFL Utils](https://gitlab.com/rc0r/afl-utils)
6. [Learn how to combine libprotobuf-mutator with libfuzzer & AFL++](https://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning)

#### Reference
1. [AFL Fuzzing Workflow](https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/)
2. https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/
3. [Corpus minimization algo](https://forallsecure.com/blog/efficient-corpus-minimization)

# Kernel Fuzzing

## Linux Kernel Fuzzing

- The primary tool of choice for kernel fuzzing is Syzkaller
- [[Syzkaller Internals]] [Syzkaller Source](https://github.com/google/syzkaller)

