---
up: "[[Tooling MoC]]"
tags:
  - "#type/tooling"
created-date: 2024-12-26
related: 
summary:
---

1. This engine is designed for fuzzing API's. 
1. It is specifically designed to uncover race-condition bug.
2. Multi-threaded Stateful Fuzzing Engine.
3. Most of the inspiration for this engine comes from Syzkaller.

## Design Requirements

1. Â You should isolate the core fuzzing engine as independent program.
3. *Target Execution Function (TEF)* - this is the function executes the API function we want to fuzz. It takes data generated by the fuzzing engine and convert the parameter which is appropriate for target API and calls the target API. The weight of TEF is stored in FPD definition.
5. *Function Prototype Definition (FPD)* - describes the argument type of the function 
	1. weight - the is used for probabilistic function call which will defines the transition from one API call to next one
	2. name  - this is the name of the function which will used to dynamically resolve the function address this is important because the number function argument and not know and we can directly call the function with variable argument using this trick 
		1. there is much better way to do this.
			1. We can instead have function pointer instead of string name and function pointer will have two parameter. One is the argument array along with type information and the number of valid argument in that array. The target function can type cast it to more appropriate data type then call the target API.
	3. argument array - this will descript the argument type and generator function
		1. Argument type field capture following information
			1. if the argument is input or output
			2. the unique id which map the id to the corresponding argument generator function. 
				1. We need to have generator function because the primitive data type it can generate different type of fuzz values and for composite data type it can generate whole structure with correct fuzz values.
	4. Return type of the function - this could be used to store the data in the *GRB*.
	5. Return values of the function - these are the possible return  values of the function in case of failure and success. This can help us later to understand the success of the fuzzer
6. *Parameter Generator Function* - this is the function pointer array which generates different parameter of the systems. Parameter could be primitive data types like int, float, string or composite data type like structures.
4. *Global Directories*  - these data structures store the global resource registration
	1. *Global Resource Bucket* - this is simple a 2-D array in which 1-D stores the resource type and the resource type then has the possible value of that resource. These values could be filled by calling the *Parameter Generator Function*, or it can be stored by  as an output of the target function call.
		1. These resource types could be File Handlers, Descriptors.
	2. *Global Target Function Execution Index (GTFEI)* - this data structure is a array which contains in the index of the *Target Execution Function*. Each TEF is assigned a weight which is basically how frequently do we want the function to be invoked.
		1. The array size is the addition of weight of all the *TEF*.
		2. array value will be the index of TEF and the TEF will be repeated as the weight of the TEF
	3. *Global TEF* - 
	4. *Global FPD* - this is the array of all the function prototype definition of all the target API we want to fuzz.
5. *Engine Execution Algorithm* - There are two mode of executing the program. One is *Raw Mode* and other is *Byte Code Mode*.
	1. *Raw Mode* - In this mode of fuzzing you are executing a new sequence of function with fuzz parameter. 
		1. This also executes in multi-threaded manner but each thread is executing its own sequence of function call and parameters. Its completely random mode of execution.
		2. Below is the algorithm which is execute in loop
			1. Randomly select a value from *GTFEI*. It is a index which basically selects the *TEF* and the corresponding *FPD*.
			2. Argument preparation - this step construct the argument base on the FPD selected in the previous step
				1. loop all the parameter of the function corresponding the generator of arguments types (both primitive and composite data types). 
				2. This is done for all the parameter once and its refreshed by calling it again every 1000 execution. 
				3. The output of the argument is placed in the bucket and there is once buck for each type of object. The bucket can also have different type of invalid value of that type. 
				4. if the argument type is of out then a pointer is create and that 
			3. Call the target function with the arguments prepared in the previous step also record the statistics like time taken to call the function. number of time the call is made. Record the return value of the function.
			4. if the return value is success then processed to next step of go to the first step(argument preparation)
			5. Record the success statistics value
			6. loop all the function prototype parameter and store the value of output parameter in the *Global Resource Bucket*. Then go to step 1.
	3. *Byte Code Mode* - In this mode of fuzzing we are executing the same sequence of function with fuzzed parameters. The sequence remains same in every loop only the parameters are fuzzed. 
		1. This mode of execution focus more on reproducibility of the bug and hence introduces more data structure. 
		2. The *Function Sequence* can be read from the file or network but the sequence has to recoverable. In case of userland fuzzing this is not an issue but in case of fuzzing kernel the program executing the fuzzer will crash the kernel thus making it irrecoverable.
		3. The main idea of this fuzzing algorithm is to uncover race-condition bugs, The Function Sequence is just a long sequence of number for example it could be 100. Then sequence is chopped into equal sized batches, each batch will be assigned to the thread to execute. So for example if there are sequence of size 100 and we want to execute it on 5 threads then each thread will be assigned 20 function to execute.
		4. The main thread does all the engine data structure initialization and initializes the execution of all the fuzz execution threads. These threads are blocks at the start fuzz case execution loop. This is done so that all the threads are synchronized at the same start point and are triggered as soon as the variable is set to start value.
		5. Algorithm for byte code mode is a follow.
			1. 
		6. Improvements
			1. In point 3 the thread synchronizing variable can be used to pause all the threads and replace the byte-code sequence with new one and continue the execution. 
6. *Execution of the Fuzzer* - There are two modes of function execution
	1. Byte code mode - 
		1. take input from file which is the call sequence, generated and mutated
	2. Raw mode - in this mode we want to execute the fuzzer as fast as possible.
7. Metrics of the fuzzer
	1. Time spend on executing individual API we are fuzzing
	2. total number of call made
	3. number of individual calls made
	4. success and failure of each calls - this will be later use to judge the success metric of each function.
8. How can this do argument preparation of nested structures.
	1. There will a Argument preparation function of top level argument type and that will call the next level of structure
9. How can we replay an existing sequence of function with parameters.
	1. Store all the function sequence and the parameter in file and have different mode of executing where you are just replaying the parameter
10. Corpus generation engine - this generates a static corpus to be executed by the execution engine.
11. Define interfaces will be like plugin where there will be call to register to the core engine.
12. Function return value as type of feedback.