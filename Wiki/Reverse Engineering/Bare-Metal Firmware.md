# Reverse Engineering [[Bare-Metal Firmware]] 

Tags: #bare-metal-firmware 

## Introduction

This post is about reverse engineering a bare-metal system identifying its functionality. Itâ€™s about digging into the binary to get an understanding it functionality. This post is specifically targeting the ARM processor and describes generic attributes of the ARM architecture. I will be using Ghidra for this exercise but IDA will also do just fine!

When you are reverse engineering you have set of hypothesis and you are trying to validate those hypotheses by reasoning it with code. A lot of these hypotheses will be rejected and you will create new ones as you gain an understanding of the program you are reversing. You might ask how should I create these hypotheses? Well, my friend, this comes from experience, the more code you read, the more binaries you reverse the better understanding you will create in your mind. You need to be a good Forward Engineer(Software Development) to be a good Reverse Engineer.

So when reversing bare-metal system you need to understand how will the device interact with the low-level system.

## Challenges

1. No binary structure, unlike Linux ELF or Windows PE.
2. Vendor may have custom binary format of the firmware update, which is parsed by the firmware running on the device.
3. Hunting and Deciphering Data Sheet which my or may not document the Memory Map
4. Memory Map is different for each SoC.
5. Compress or encrypted firmware binary which is processed by the bootloader.

Some of these point will become relevant as you progress with the blog.

## Bare-Metal RTOS System

The feature that is necessary to have a basic RTOS framework like, memory management, task scheduling.

1. If the binary is RTOS base then it will have a task scheduling function. Task scheduler will have a function to save a restore task context and the term used to describe this is Process Control Block.
2. Identify the most used function and try to understand is from high level perspective are they usually will be manipulating buffers, setting up data structures. There will likely be memcpy, memcmp, sprintf function. Identify these function in early-stage as you will encounter them frequently and will make use of reversing task little easy.
3. If the system is using crypto-function like encryption/decryption, or CRC algorithm you can search using FindCrypt plugin. Once you have identified one function try to map-out all the related functions by correlating it will open-source implementation of the crypto algorithm. Next look into how this crypto function is used, how data is it hashing/encrypting how is the result used/stored.

## Memory Map I/O

1. Identify the Memory Map of the controller and create memory blocks in the disassembler like Ghidra or IDA-Pro. Look into references to the function in the memory map. These functions are most likely interacting with the particular Peripheral like UART, USB, Timer etc. These functions are also executing privilege mode.
2. Search for a datasheet and search or memory map want what all peripherals does it support. This will aid you in the above task.

## Debug Information

1. How is debug logging is done. Where is the data sent UART? This helps you to clean out UART function.
2. Strings are also very important as they give clue about the function. So investigate them.

## Interrupt Handler

1. Identify function processing Interrupts. This can be done by searching functions which are executing privileged operations like manipulating CPSR, SPSR registers. This function may have wrapper function Investigate their parameter and see what and how the data is passed. There will be C struct which you need to understand/reconstruct. Ghidra Auto-struct feature was very useful for this.
2. There is a high possibility that the above-mentioned function will be an Interrupt Service routine. Look into different methods by which this routine is triggered. Is it by Software Interrupt (SWI instruction) or by Vector Interrupt Controller (VIC)?
3. Look into Reset function in vector table what set it is doing :
    1. How is it transferring control to the User-Mode task?
    2. How is the task setup been done?
    3. What data-structures are initiated/nulled-out?
4. There are two sources of interrupt one via Software which is generated by SWI instruction. Another is hardware Interrupt which is handled by FIQ and IRQ interrupt handler.
5. Look into functions pointed by Vector Table, is VT been re-mapped later, where and how?

## Real-life example

Give example of wolfBoot which has custom firmware binary format.


## Reference
1. [Secure boot with wolfBoot (wolkSSL folks)](https://www.youtube.com/watch?v=u5sP31WHy_o)
2. [Writing Bare-Metal ARM OS](https://github.com/umanovskis/baremetal-arm/tree/master/doc)
3. [A Journey Through the Secrets of Firmware: Exploring the Foundations](http://joursoir.net/post/boot_process_theory/)